// Generated by CoffeeScript 1.6.3
(function() {
  var MODULE_NAME, SLIDER_TAG, angularize, gap, halfWidth, hide, inputEvents, module, offset, offsetLeft, pixelize, qualifiedDirectiveDefinition, roundStep, show, sliderDirective, width;

  MODULE_NAME = 'uiSlider';

  SLIDER_TAG = 'slider';

  angularize = function(element) {
    return angular.element(element);
  };

  pixelize = function(position) {
    return "" + position + "px";
  };

  hide = function(element) {
    return element.css({
      opacity: 0
    });
  };

  show = function(element) {
    return element.css({
      opacity: 1
    });
  };

  offset = function(element, position) {
    return element.css({
      left: position
    });
  };

  halfWidth = function(element) {
    return element[0].offsetWidth / 2;
  };

  offsetLeft = function(element) {
    return element[0].offsetLeft;
  };

  width = function(element) {
    return element[0].offsetWidth;
  };

  gap = function(element1, element2) {
    return offsetLeft(element2) - offsetLeft(element1) - width(element1);
  };

  roundStep = function(value, precision, step, floor) {
    var decimals, remainder, roundedValue, steppedValue;
    if (floor == null) {
      floor = 0;
    }
    if (step == null) {
      step = 1 / Math.pow(10, precision);
    }
    remainder = (value - floor) % step;
    steppedValue = remainder > (step / 2) ? value + step - remainder : value - remainder;
    decimals = Math.pow(10, precision);
    roundedValue = steppedValue * decimals / decimals;
    return roundedValue.toFixed(precision);
  };

  inputEvents = {
    mouse: {
      start: 'mousedown',
      move: 'mousemove',
      end: 'mouseup'
    },
    touch: {
      start: 'touchstart',
      move: 'touchmove',
      end: 'touchend'
    }
  };

  sliderDirective = function($timeout) {
    return {
      restrict: 'EA',
      scope: {
        floor: '@',
        ceiling: '@',
        step: '@',
        precision: '@',
        translate: '&',
        ngModel: '=?',
        ngModelLow: '=?',
        ngModelHigh: '=?'
      },
      template: '<span class="bar"></span>\
               <span class="bar selection"></span>\
               <span class="pointer"></span>\
               <span class="pointer"></span>\
               <span class="bubble selection">Range: {{ translate({value: diff}) }}</span>\
               <span class="bubble limit">{{ translate({value: floor}) }}</span>\
               <span class="bubble limit">{{ translate({value: ceiling}) }}</span>\
               <span class="bubble">{{ translate({value: ngModelLow}) }}</span>\
               <span class="bubble">{{ translate({value: ngModelHigh}) }}</span>\
               <span class="bubble">{{ translate({value: ngModelLow}) }} - {{ translate({value: ngModelHigh}) }}</span>',
      link: function(scope, element, attributes) {
        var barWidth, boundToInputs, ceilBub, cmbBub, dimensions, e, flrBub, fullBar, highBub, lowBub, maxOffset, maxPtr, maxValue, minOffset, minPtr, minValue, ngDocument, offsetRange, pointerHalfWidth, range, selBar, selBub, updateDOM, valueRange, w, watchables, _i, _len, _ref;
        range = true;
        _ref = (function() {
          var _i, _len, _ref, _results;
          _ref = element.children();
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            e = _ref[_i];
            _results.push(angularize(e));
          }
          return _results;
        })(), fullBar = _ref[0], selBar = _ref[1], minPtr = _ref[2], maxPtr = _ref[3], selBub = _ref[4], flrBub = _ref[5], ceilBub = _ref[6], lowBub = _ref[7], highBub = _ref[8], cmbBub = _ref[9];
        watchables = ['ngModelLow', 'floor', 'ceiling', 'ngModelHigh'];
        boundToInputs = false;
        ngDocument = angularize(document);
        if (!attributes.translate) {
          scope.translate = function(value) {
            return value.value;
          };
        }
        pointerHalfWidth = barWidth = minOffset = maxOffset = minValue = maxValue = valueRange = offsetRange = void 0;
        dimensions = function() {
          var value, _i, _len;
          if (scope.precision == null) {
            scope.precision = 0;
          }
          if (scope.step == null) {
            scope.step = 1;
          }
          for (_i = 0, _len = watchables.length; _i < _len; _i++) {
            value = watchables[_i];
            scope[value] = parseInt(roundStep(parseFloat(scope[value]), parseInt(scope.precision), parseFloat(scope.step), parseFloat(scope.floor)), 10);
          }
          scope.diff = roundStep(scope.ngModelHigh - scope.ngModelLow, parseInt(scope.precision), parseFloat(scope.step), parseFloat(scope.floor));
          pointerHalfWidth = halfWidth(minPtr);
          barWidth = width(fullBar);
          minOffset = 0;
          maxOffset = barWidth - width(minPtr);
          minValue = parseFloat(attributes.floor);
          maxValue = parseFloat(attributes.ceiling);
          valueRange = maxValue - minValue;
          return offsetRange = maxOffset - minOffset;
        };
        updateDOM = function() {
          var adjustBubbles, bindToInputEvents, fitToBar, percentOffset, percentToOffset, percentValue, setBindings, setPointers;
          dimensions();
          percentOffset = function(offset) {
            return ((offset - minOffset) / offsetRange) * 100;
          };
          percentValue = function(value) {
            return ((value - minValue) / valueRange) * 100;
          };
          percentToOffset = function(percent) {
            return pixelize(percent * offsetRange / 100);
          };
          fitToBar = function(element) {
            return offset(element, pixelize(Math.min(Math.max(0, offsetLeft(element)), barWidth - width(element))));
          };
          setPointers = function() {
            var newHighValue, newLowValue;
            offset(ceilBub, pixelize(barWidth - width(ceilBub)));
            newLowValue = percentValue(scope.ngModelLow);
            offset(minPtr, percentToOffset(newLowValue));
            offset(lowBub, pixelize(offsetLeft(minPtr) - (halfWidth(lowBub)) + pointerHalfWidth));
            newHighValue = percentValue(scope.ngModelHigh);
            offset(maxPtr, percentToOffset(newHighValue));
            offset(highBub, pixelize(offsetLeft(maxPtr) - (halfWidth(highBub)) + pointerHalfWidth));
            offset(selBar, pixelize(offsetLeft(minPtr) + pointerHalfWidth));
            selBar.css({
              width: percentToOffset(newHighValue - newLowValue)
            });
            offset(selBub, pixelize(offsetLeft(selBar) + halfWidth(selBar) - halfWidth(selBub)));
            return offset(cmbBub, pixelize(offsetLeft(selBar) + halfWidth(selBar) - halfWidth(cmbBub)));
          };
          adjustBubbles = function() {
            var bubToAdjust;
            fitToBar(lowBub);
            bubToAdjust = highBub;
            fitToBar(highBub);
            fitToBar(selBub);
            if (gap(lowBub, highBub) < 10) {
              hide(lowBub);
              hide(highBub);
              fitToBar(cmbBub);
              show(cmbBub);
              bubToAdjust = cmbBub;
            } else {
              show(lowBub);
              show(highBub);
              hide(cmbBub);
              bubToAdjust = highBub;
            }
            if (gap(flrBub, lowBub) < 5) {
              hide(flrBub);
            } else {
              if (gap(flrBub, bubToAdjust) < 5) {
                hide(flrBub);
              } else {
                show(flrBub);
              }
            }
            if (gap(lowBub, ceilBub) < 5) {
              return hide(ceilBub);
            } else {
              if (gap(bubToAdjust, ceilBub) < 5) {
                return hide(ceilBub);
              } else {
                return show(ceilBub);
              }
            }
          };
          bindToInputEvents = function(pointer, ref, events) {
            var onEnd, onMove, onStart;
            onEnd = function() {
              pointer.removeClass('active');
              ngDocument.unbind(events.move);
              return ngDocument.unbind(events.end);
            };
            onMove = function(event) {
              var eventX, newOffset, newPercent, newValue;
              eventX = event.clientX || event.touches[0].clientX;
              newOffset = eventX - element[0].getBoundingClientRect().left - pointerHalfWidth;
              newOffset = Math.max(Math.min(newOffset, maxOffset), minOffset);
              newPercent = percentOffset(newOffset);
              newValue = minValue + (valueRange * newPercent / 100.0);
              if (range) {
                if (ref === 'ngModelLow') {
                  if (newValue > scope.ngModelHigh) {
                    ref = 'ngModelHigh';
                    minPtr.removeClass('active');
                    maxPtr.addClass('active');
                  }
                } else {
                  if (newValue < scope.ngModelLow) {
                    ref = 'ngModelLow';
                    maxPtr.removeClass('active');
                    minPtr.addClass('active');
                  }
                }
              }
              newValue = roundStep(newValue, parseInt(scope.precision), parseFloat(scope.step), parseFloat(scope.floor));
              scope[ref] = parseInt(newValue, 10);
              return scope.$apply();
            };
            onStart = function(event) {
              pointer.addClass('active');
              dimensions();
              event.stopPropagation();
              event.preventDefault();
              ngDocument.bind(events.move, onMove);
              return ngDocument.bind(events.end, onEnd);
            };
            return pointer.bind(events.start, onStart);
          };
          setBindings = function() {
            var bind, inputMethod, _i, _len, _ref1, _results;
            boundToInputs = true;
            bind = function(method) {
              bindToInputEvents(minPtr, 'ngModelLow', inputEvents[method]);
              return bindToInputEvents(maxPtr, 'ngModelHigh', inputEvents[method]);
            };
            _ref1 = ['touch', 'mouse'];
            _results = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              inputMethod = _ref1[_i];
              _results.push(bind(inputMethod));
            }
            return _results;
          };
          setPointers();
          adjustBubbles();
          if (!boundToInputs) {
            return setBindings();
          }
        };
        $timeout(updateDOM);
        for (_i = 0, _len = watchables.length; _i < _len; _i++) {
          w = watchables[_i];
          scope.$watch(w, updateDOM);
        }
        window.addEventListener("resize", updateDOM);
        return scope.$on('edit-section-visible', updateDOM);
      }
    };
  };

  qualifiedDirectiveDefinition = ['$timeout', sliderDirective];

  module = function(window, angular) {
    return angular.module(MODULE_NAME, []).directive(SLIDER_TAG, qualifiedDirectiveDefinition);
  };

  module(window, window.angular);

}).call(this);
